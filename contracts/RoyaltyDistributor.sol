
//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/common/ERC2981.sol";

abstract contract RoyaltyDistributor is ERC2981 {

struct UniqueRoyaltyInfo {
    address receiver;
    uint96 royaltyPercentage;
  }

  struct GenerativeRoyaltyInfo {
    address receiver;
    uint96 artistPercentage;
    address valorize;
    uint96 valorizePercentage;
  }

  mapping(uint256 => UniqueRoyaltyInfo) public _uniqueTokenRoyaltyInfo;
  mapping(uint256 => GenerativeRoyaltyInfo) public _generativeTokenRoyaltyInfo;

  function _feeDenominator() internal override pure virtual returns (uint96) {
      return 100;
  }
  
  function calculateUniqueRoyalty(uint256 _salePrice) pure public returns(uint256) {
    return (_salePrice / _feeDenominator()) * 10;
  }

  function calculateGenerativeRoyalty(uint256 _salePrice) pure public returns(uint256) {
    return (_salePrice / _feeDenominator()) * 5;
  }

//set royalty based on TokenIds
  function _setUniqueTokenRoyalty(
    uint256[] memory tokenId,
    address[] memory receiver
  ) public virtual {
    for(uint256 i=0; i <= tokenId.length; i++ ){
      // require(
      //   tokenId[i] <= remainingWhaleTokenIds[0] 
      //   || (tokenId[i] >= startSeal && tokenId[i] <= remainingSealTokenIds[0]) 
      //   || (tokenId[i] >= startPlankton && tokenId[i] <= remainingPlanktonTokenIds[0]), "these tokenIds do not have unique art");
      require(receiver[i] != address(0), "ERC2981: Invalid parameters");
      _uniqueTokenRoyaltyInfo[tokenId[i]] = UniqueRoyaltyInfo(receiver[i], 10); //feenumerator is fixed to 10%
    }
  }
//just create a contract with 10% send it to a contract and let the artist draw royalties from it
//logs of which token Ids have been traded --> oracle from chainlink? 
//Make a smart contract for each artist, every artist should be able to draw their funds
// one smart contract to log everything... 
//research on how to do it:
//1. 12 smart contracts?
//2. one SC per 12 artists --> figure how to keep track of the funds
//3. no smart contracts --> manually? no idea how to split... 

  //array of tokenId and receiver should be aligned 
  function _setGenerativeTokenRoyalty(
    uint256[] memory tokenId,
    address[] memory receiver
  ) internal virtual {
      for(uint256 i=0; i <= tokenId.length; i++ ) {
        //require(5 <= _feeDenominator(), "ERC2981: royalty fee will exceed salePrice");
        require(receiver[i] != address(0), "ERC2981: Invalid parameters");
        // require(
        //   (tokenId[i] > remainingWhaleTokenIds[0] && tokenId[i] < startSeal)
        //   || (tokenId[i] > remainingSealTokenIds[0] && tokenId[i] < startPlankton) 
        //   || tokenId[i] > remainingPlanktonTokenIds[0], "these tokenIds do not have generative art");
        _generativeTokenRoyaltyInfo[tokenId[i]] = GenerativeRoyaltyInfo(receiver[i], 5, address(this), 5); //feenumerator is fixed to 5%
      }
  }
  //for each tokenId from 1 to 10 we want to map 1 artist address that receives 10% royalty per sale
  function uniqueTokenRoyaltyInfo(uint256 _tokenId, uint256 _salePrice) public view virtual returns (address, uint256) {
    UniqueRoyaltyInfo memory uniqueRoyalty = _uniqueTokenRoyaltyInfo[_tokenId];
    uint256 royaltyAmount = calculateUniqueRoyalty(_salePrice);
    return (uniqueRoyalty.receiver, royaltyAmount);
  }

  function generativeTokenRoyaltyInfo(uint256 _tokenId, uint256 _salePrice) public view virtual returns (address, uint256, address, uint256) {
    GenerativeRoyaltyInfo memory generativeRoyalty = _generativeTokenRoyaltyInfo[_tokenId];
    uint256 royaltyAmount = calculateGenerativeRoyalty(_salePrice);
    return (generativeRoyalty.receiver, royaltyAmount, generativeRoyalty.valorize, royaltyAmount);
  }
}
//An ethereum address belonging to the contractor will be put in the contract’s 
//royalty calculator as per the EIP-2981 royalty standard for the sales of 
//their 1 of 1 nft with a 10% royalty fee. 

//For the artworks generated by the 
//contractor that will not be 1 of 1, payment royalties will be directed 
//to a smart contract that will split those royalties 5% for the 
//contractor’s address and 5% for an address belonging to Valorize.