
//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

contract RoyaltyDistributor {

  string URI;

  constructor(  
    string memory _URI
  ) {
    URI = _URI;
  }


  struct UniqueRoyaltyInfo {
    address artistAddress; 
    uint96 royaltyPercentage;
  }

  struct GenerativeRoyaltyInfo {
    address artistAddress;
    uint96 artistPercentage;
    address valorize;
    uint96 valorizePercentage;
  }

  mapping(uint256 => UniqueRoyaltyInfo) public _uniqueTokenRoyaltyInfo;
  mapping(uint256 => GenerativeRoyaltyInfo) public _generativeTokenRoyaltyInfo;

  function _feeDenominator() internal pure virtual returns (uint96) {
      return 100;
  }
  
  function calculateUniqueRoyalty(uint256 _salePrice) pure public returns(uint256) {
    return (_salePrice / _feeDenominator()) * 10;
  }

  function calculateGenerativeRoyalty(uint256 _salePrice) pure public returns(uint256) {
    return (_salePrice / _feeDenominator()) * 5;
  }

//set royalty based on TokenIds
  function _setUniqueTokenRoyalty(
    uint256[] memory tokenId,
    address artistAddress
  ) public payable virtual {
    for(uint256 i=0; i <= tokenId.length; i++ ) {
      require(artistAddress != address(0), "ERC2981: Invalid parameters");
      _uniqueTokenRoyaltyInfo[tokenId[i]] = UniqueRoyaltyInfo(artistAddress, 10); //feenumerator is fixed to 10%
    }
  }
//just create a contract with 10% send it to a contract and let the artist draw royalties from it
//logs of which token Ids have been traded --> oracle from chainlink? 
//Make a smart contract for each artist, every artist should be able to draw their funds
// one smart contract to log everything... 
//research on how to do it:
//1. 12 smart contracts?
//2. one SC per 12 artists --> figure how to keep track of the funds
//3. no smart contracts --> manually? no idea how to split... 

  function _setGenerativeTokenRoyalty(
    uint256[] memory tokenId,
    address artistAddress,
    address valorizeAddress
  ) internal virtual {
      for(uint256 i=0; i <= tokenId.length; i++ ) {
        require(artistAddress != address(0), "ERC2981: Invalid parameters");
        _generativeTokenRoyaltyInfo[tokenId[i]] = GenerativeRoyaltyInfo(artistAddress, 5, valorizeAddress, 5); //feenumerator is fixed to 5%
      }
  }
  //for each tokenId from 1 to 10 we want to map 1 artist address that receives 10% royalty per sale
  function uniqueTokenRoyaltyInfo(uint256 _tokenId, uint256 _salePrice) public view virtual returns (address, uint256) {
    UniqueRoyaltyInfo memory uniqueRoyalty = _uniqueTokenRoyaltyInfo[_tokenId];
    uint256 royaltyAmount = calculateUniqueRoyalty(_salePrice);
    return (uniqueRoyalty.artistAddress, royaltyAmount);
  }

  function generativeTokenRoyaltyInfo(uint256 _tokenId, uint256 _salePrice) public view virtual returns (address, uint256, address, uint256) {
    GenerativeRoyaltyInfo memory generativeRoyalty = _generativeTokenRoyaltyInfo[_tokenId];
    uint256 royaltyAmount = calculateGenerativeRoyalty(_salePrice);
    return (generativeRoyalty.artistAddress, royaltyAmount, generativeRoyalty.valorize, royaltyAmount);
  }
}
//An ethereum address belonging to the contractor will be put in the contract’s 
//royalty calculator as per the EIP-2981 royalty standard for the sales of 
//their 1 of 1 nft with a 10% royalty fee. 

//For the artworks generated by the 
//contractor that will not be 1 of 1, payment royalties will be directed 
//to a smart contract that will split those royalties 5% for the 
//contractor’s address and 5% for an address belonging to Valorize.